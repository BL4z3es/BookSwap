<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chaotic Text Animation</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #050505;
            color: #fff;
            font-family: sans-serif;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
<canvas id="canvas"></canvas>

<script>
    /**
     * Configuration Settings
     * Customize these values to change the behavior of the animation.
     */
    const config = {
        text: "BookSwap",
        // New settings for chance-based text swapping
        alternateText: "swap these balls with ur brain", 
        swapChance: 0.01 ,          // 30% chance to switch to alternate text
        
        fontSize: 120,
        fontFamily: "Verdana, sans-serif",
        textColor: "#00ffcc",
        
        // Particle settings
        particleCount: 5000,      // Total number of flying letters
        charSet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789", // Characters to use for particles
        particleSize: 15,         // Font size of tiny letters
        
        // Animation timings (in milliseconds)
        holdDuration: 3000,       // How long to hold the word
        transitionDuration: 2000, // Approx time to assemble (used for internal logic)
        
        // Physics
        ease: 0.08,               // 0.01 (slow) to 1.0 (instant) - ease to target
        chaosSpeed: 8,            // Max speed in chaos mode
        attractionRadius: 100,    // Mouse interaction radius
        mouseForce: 12           // Mouse push force
    };

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    // State management
    let width, height;
    let particles = [];
    let textPoints = [];
    let currentText = config.text; // Track which text is currently active
    let animationState = 'chaos'; // 'chaos', 'assembling', 'holding', 'dispersing'
    let stateStartTime = Date.now();
    let animationFrameId;

    /**
     * Particle Class
     * Represents a single floating letter
     */
    class Particle {
        constructor() {
            this.reset();
        }

        reset() {
            this.x = Math.random() * width;
            this.y = Math.random() * height;
            // Velocity
            this.vx = (Math.random() - 0.5) * config.chaosSpeed;
            this.vy = (Math.random() - 0.5) * config.chaosSpeed;
            
            this.char = config.charSet[Math.floor(Math.random() * config.charSet.length)];
            
            // Target position (if assigned to a point in the text)
            this.tx = null;
            this.ty = null;
            
            // Is this particle currently part of the text?
            this.active = false;
        }

        update(mouse) {
            // State: CHAOS or DISPERSING
            if (animationState === 'chaos' || animationState === 'dispersing') {
                this.x += this.vx;
                this.y += this.vy;

                // Bounce off walls
                if (this.x < 0 || this.x > width) this.vx *= -1;
                if (this.y < 0 || this.y > height) this.vy *= -1;
                
                // Add some chaotic random movement
                this.vx += (Math.random() - 0.5) * 0.2;
                this.vy += (Math.random() - 0.5) * 0.2;
                
                // Dampen speed if too fast
                const speed = Math.sqrt(this.vx*this.vx + this.vy*this.vy);
                if (speed > config.chaosSpeed) {
                    this.vx = (this.vx / speed) * config.chaosSpeed;
                    this.vy = (this.vy / speed) * config.chaosSpeed;
                }
            } 
            // State: ASSEMBLING or HOLDING
            else if ((animationState === 'assembling' || animationState === 'holding') && this.active) {
                // Move towards target
                const dx = this.tx - this.x;
                const dy = this.ty - this.y;
                
                this.x += dx * config.ease;
                this.y += dy * config.ease;
                
                // Add slight jitter when holding to keep it alive
                if (animationState === 'holding') {
                    this.x += (Math.random() - 0.5) * 0.5;
                    this.y += (Math.random() - 0.5) * 0.5;
                }
            }
            // Non-active particles during assembly continue to swirl
            else {
                this.x += this.vx;
                this.y += this.vy;
                 // Bounce off walls
                if (this.x < 0 || this.x > width) this.vx *= -1;
                if (this.y < 0 || this.y > height) this.vy *= -1;
            }

            // Mouse Interaction (Push away)
            if (mouse.x !== null) {
                const dx = this.x - mouse.x;
                const dy = this.y - mouse.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                if (dist < config.attractionRadius) {
                    const angle = Math.atan2(dy, dx);
                    const force = (config.attractionRadius - dist) / config.attractionRadius;
                    const pushX = Math.cos(angle) * force * config.mouseForce;
                    const pushY = Math.sin(angle) * force * config.mouseForce;
                    
                    this.x += pushX;
                    this.y += pushY;
                }
            }
        }

        draw(ctx) {
            ctx.fillStyle = this.active ? config.textColor : `rgba(255, 255, 255, 0.3)`;
            ctx.font = `${config.particleSize}px monospace`;
            ctx.fillText(this.char, this.x, this.y);
        }
    }

    // Initialize
    function init() {
        resize();
        window.addEventListener('resize', resize);
        
        // Create pool of particles
        particles = [];
        for (let i = 0; i < config.particleCount; i++) {
            particles.push(new Particle());
        }

        restartSequence();
        animate();
    }

    function resize() {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
    }

    /**
     * Calculate points for the text by drawing it to an offscreen canvas
     * and reading the pixel data.
     */
    function calculateTextPoints() {
        // Create offscreen canvas
        const offCanvas = document.createElement('canvas');
        offCanvas.width = width;
        offCanvas.height = height;
        const offCtx = offCanvas.getContext('2d');

        offCtx.font = `bold ${config.fontSize}px ${config.fontFamily}`;
        offCtx.textAlign = 'center';
        offCtx.textBaseline = 'middle';
        offCtx.fillStyle = '#fff';
        offCtx.fillText(currentText, width / 2, height / 2); // Use currentText variable

        // Get pixel data
        // We scan in a grid to reduce processing (skip density)
        const density = 6; // Scan every n-th pixel
        const imageData = offCtx.getImageData(0, 0, width, height).data;
        
        textPoints = [];
        for (let y = 0; y < height; y += density) {
            for (let x = 0; x < width; x += density) {
                // If pixel alpha > 128
                const index = (y * width + x) * 4;
                if (imageData[index + 3] > 128) {
                    textPoints.push({x, y});
                }
            }
        }
    }

    function assignParticlesToTargets() {
        // Shuffle particles to vary who goes where
        const availableParticles = [...particles].sort(() => Math.random() - 0.5);
        
        // Reset all particles active state
        particles.forEach(p => p.active = false);

        // Assign one particle to each test point
        for (let i = 0; i < textPoints.length; i++) {
            if (i < availableParticles.length) {
                const p = availableParticles[i];
                p.tx = textPoints[i].x;
                p.ty = textPoints[i].y;
                p.active = true;
            } else {
                // Not enough particles!
                break; 
            }
        }
    }

    function explodeParticles() {
        particles.forEach(p => {
             // Give them a random push outward from center
             const dx = p.x - width/2;
             const dy = p.y - height/2;
             const dist = Math.sqrt(dx*dx + dy*dy) + 0.1;
             
             // Initial outward explosion velocity
             p.vx = (dx / dist) * (Math.random() * 10 + 5);
             p.vy = (dy / dist) * (Math.random() * 10 + 5);
             p.active = false;
        });
    }

    function restartSequence() {
        stateStartTime = Date.now();
        animationState = 'chaos';
        calculateTextPoints();
    }

    // Mouse tracking
    const mouse = { x: null, y: null };
    window.addEventListener('mousemove', e => {
        mouse.x = e.clientX;
        mouse.y = e.clientY;
    });
    window.addEventListener('mouseleave', () => {
        mouse.x = null;
        mouse.y = null;
    });

    // Main Loop
    function animate() {
        ctx.clearRect(0, 0, width, height);
        
        const now = Date.now();
        const elapsed = now - stateStartTime;

        // State Machine
        switch (animationState) {
            case 'chaos':
                // Swirl for a bit (e.g., 2 seconds of just chaos)
                // Or immediately start transition planning
                if (elapsed > 1500) {
                    animationState = 'assembling';
                    stateStartTime = now;
                    assignParticlesToTargets();
                }
                break;
                
            case 'assembling':
                // Wait for visual assembly (not strictly timed, but we wait for easing to finish mostly)
                // We'll use a fixed timer + hold time
                if (elapsed > 2000) { // Give it 2 seconds to form
                    animationState = 'holding';
                    stateStartTime = now;
                }
                break;

            case 'holding':
                if (elapsed > config.holdDuration) {
                    animationState = 'dispersing';
                    stateStartTime = now;
                    explodeParticles();
                }
                break;

            case 'dispersing':
                // Allow explosion to settle back into gentle chaos
                if (elapsed > 1000) {
                    animationState = 'chaos';
                    stateStartTime = now;
                    
                    // Logic to randomise text for the next round
                    if (Math.random() < config.swapChance) {
                        currentText = config.alternateText;
                    } else {
                        currentText = config.text;
                    }
                    // Recalculate points for the chosen text
                    calculateTextPoints();
                }
                break;
        }

        particles.forEach(p => {
            p.update(mouse);
            p.draw(ctx);
        });

        animationFrameId = requestAnimationFrame(animate);
    }

    // Start
    init();

</script>
</body>
</html>
