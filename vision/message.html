<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chaotic Text Animation</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #050505;
            color: #fff;
            font-family: sans-serif;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
<canvas id="canvas"></canvas>

<script>
    /**
     * Configuration Settings
     * Customize these values to change the behavior of the animation.
     */
    const config = {
        // Sequence of texts to display
        textSequence: [
            { text: "BookSwap", renderMethod: "all" },
            { text: "Share. Read. Repeat.", renderMethod: "sequential" },
            { text: "Join the Community", renderMethod: "sequential" },
            { text: "Discover New Worlds", renderMethod: "sequential" },
            { text: "Empowering Readers Everywhere", renderMethod: "sequential" },

        ],
        
        wordDelay: 600,         // Delay between words appearing in sequential mode (ms)
        fontSize: 120,
        fontFamily: "Verdana, sans-serif",
        textColor: "#00ffcc",
        
        // Particle settings
        particleCount: 5000,      // Total number of flying letters
        charSet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789", // Characters to use for particles
        particleSize: 15,         // Font size of tiny letters
        
        // Animation timings (in milliseconds)
        holdDuration: 3000,       // How long to hold the word
        transitionDuration: 2000, // Approx time to assemble (per group)
        
        // Physics
        ease: 0.08,               // 0.01 (slow) to 1.0 (instant) - ease to target
        chaosSpeed: 8,            // Max speed in chaos mode
        attractionRadius: 100,    // Mouse interaction radius
        mouseForce: 12           // Mouse push force
    };

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    // State management
    let width, height;
    let particles = [];
    
    // textPointGroups will store arrays of points. 
    // Example: [ [pointsForWord1], [pointsForWord2] ]
    let textPointGroups = []; 
    
    let currentSequenceIndex = 0;
    
    let animationState = 'chaos'; // 'chaos', 'assembling', 'holding', 'dispersing'
    let stateStartTime = Date.now();
    let currentAssemblyDuration = 2000; // Will be calculated dynamically
    let animationFrameId;

    /**
     * Particle Class
     * Represents a single floating letter
     */
    class Particle {
        constructor() {
            this.reset();
        }

        reset() {
            this.x = Math.random() * width;
            this.y = Math.random() * height;
            // Velocity
            this.vx = (Math.random() - 0.5) * config.chaosSpeed;
            this.vy = (Math.random() - 0.5) * config.chaosSpeed;
            
            this.char = config.charSet[Math.floor(Math.random() * config.charSet.length)];
            
            // Target position (if assigned to a point in the text)
            this.tx = null;
            this.ty = null;
            
            // Interaction properties
            this.active = false;
            this.delay = 0; // Delay before starting to assemble (for sequential)
        }

        update(mouse) {
            // Check if we should actually be assembling based on delay
            let shouldAssemble = false;
            if (this.active) {
                if (animationState === 'holding') {
                    shouldAssemble = true;
                } else if (animationState === 'assembling') {
                    const elapsed = Date.now() - stateStartTime;
                    if (elapsed >= this.delay) {
                        shouldAssemble = true;
                    }
                }
            }

            // State: CHAOS, DISPERSING, or WAITING (Assemble delay active)
            if (!shouldAssemble) {
                // Determine behavior: classic physics
                this.x += this.vx;
                this.y += this.vy;

                // Bounce off walls
                if (this.x < 0 || this.x > width) this.vx *= -1;
                if (this.y < 0 || this.y > height) this.vy *= -1;
                
                // Add some chaotic random movement
                this.vx += (Math.random() - 0.5) * 0.2;
                this.vy += (Math.random() - 0.5) * 0.2;
                
                // Dampen speed if too fast
                const speed = Math.sqrt(this.vx*this.vx + this.vy*this.vy);
                if (speed > config.chaosSpeed) {
                    this.vx = (this.vx / speed) * config.chaosSpeed;
                    this.vy = (this.vy / speed) * config.chaosSpeed;
                }
            } 
            // State: ASSEMBLING (Post-delay) or HOLDING
            else {
                // Move towards target
                const dx = this.tx - this.x;
                const dy = this.ty - this.y;
                
                this.x += dx * config.ease;
                this.y += dy * config.ease;
                
                // Add slight jitter when holding to keep it alive
                if (animationState === 'holding') {
                    this.x += (Math.random() - 0.5) * 0.5;
                    this.y += (Math.random() - 0.5) * 0.5;
                }
            }

            // Mouse Interaction (Push away)
            if (mouse.x !== null) {
                const dx = this.x - mouse.x;
                const dy = this.y - mouse.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                if (dist < config.attractionRadius) {
                    const angle = Math.atan2(dy, dx);
                    const force = (config.attractionRadius - dist) / config.attractionRadius;
                    const pushX = Math.cos(angle) * force * config.mouseForce;
                    const pushY = Math.sin(angle) * force * config.mouseForce;
                    
                    this.x += pushX;
                    this.y += pushY;
                }
            }
        }

        draw(ctx) {
            // If active and assembling/holding, color it
            // If waiting for delay, maybe dim it? For now keep same logic
            ctx.fillStyle = this.active ? config.textColor : `rgba(255, 255, 255, 0.3)`;
            ctx.font = `${config.particleSize}px monospace`;
            ctx.fillText(this.char, this.x, this.y);
        }
    }

    // Initialize
    function init() {
        resize();
        window.addEventListener('resize', resize);
        
        // Create pool of particles
        particles = [];
        for (let i = 0; i < config.particleCount; i++) {
            particles.push(new Particle());
        }

        restartSequence();
        animate();
    }

    function resize() {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
    }

    /**
     * Calculate points for the text based on current render method
     */
    function calculateTextPoints() {
        textPointGroups = [];
        
        const currentEntry = config.textSequence[currentSequenceIndex];
        const text = currentEntry.text;
        const method = currentEntry.renderMethod;

        // Create offscreen canvas
        const offCanvas = document.createElement('canvas');
        offCanvas.width = width;
        offCanvas.height = height;
        const offCtx = offCanvas.getContext('2d');

        offCtx.font = `bold ${config.fontSize}px ${config.fontFamily}`;
        offCtx.textBaseline = 'middle';
        offCtx.fillStyle = '#fff';
        
        // Helper to scan particles from offscreen canvas
        const scanPixels = () => {
             const density = 6; 
             const imageData = offCtx.getImageData(0, 0, width, height).data;
             const points = [];
             for (let y = 0; y < height; y += density) {
                for (let x = 0; x < width; x += density) {
                    const index = (y * width + x) * 4;
                    if (imageData[index + 3] > 128) {
                        points.push({x, y});
                    }
                }
             }
             return points;
        };

        if (method === 'sequential') {
            // Split text into words and render individually to capture groups
            // We need to calculate layout manually to center the whole sentence
            const words = text.split(' ');
            
            // Measure total width to center it
            // Note: Simplistic measurement. 
            // Proper kerning between words is approximated by space character width.
            const spaceWidth = offCtx.measureText(' ').width;
            const wordWidths = words.map(w => offCtx.measureText(w).width);
            const totalTextWidth = wordWidths.reduce((a, b) => a + b, 0) + (words.length - 1) * spaceWidth;
            
            let startX = (width - totalTextWidth) / 2;
            const y = height / 2;

            // Render each word
            words.forEach((word, idx) => {
                offCtx.clearRect(0, 0, width, height);
                offCtx.textAlign = 'left'; 
                offCtx.fillText(word, startX, y);
                
                textPointGroups.push(scanPixels());
                
                startX += wordWidths[idx] + spaceWidth;
            });

        } else {
            // 'all' method: Render everything at once
            offCtx.textAlign = 'center';
            offCtx.fillText(text, width / 2, height / 2);
            textPointGroups.push(scanPixels());
        }
    }

    function assignParticlesToTargets() {
        const currentEntry = config.textSequence[currentSequenceIndex];
        const method = currentEntry.renderMethod;

        // Shuffle particles
        const availableParticles = [...particles].sort(() => Math.random() - 0.5);
        
        let pIndex = 0;

        // Reset all particles
        particles.forEach(p => {
             p.active = false;
             p.delay = 0;
        });

        // Loop through groups
        textPointGroups.forEach((group, groupIdx) => {
            // Determine delay for this group
            let delay = 0;
            if (method === 'sequential') {
                delay = groupIdx * config.wordDelay;
            }

            // Assign particles to this group's points
            for (let i = 0; i < group.length; i++) {
                if (pIndex < availableParticles.length) {
                    const p = availableParticles[pIndex];
                    p.tx = group[i].x;
                    p.ty = group[i].y;
                    p.active = true;
                    p.delay = delay;
                    pIndex++;
                } else {
                    break;
                }
            }
        });
        
        // Calculate how long assembly should take
        // It's the standard duration plus the maximum delay
        const maxDelay = (textPointGroups.length - 1) * (method === 'sequential' ? config.wordDelay : 0);
        currentAssemblyDuration = config.transitionDuration + maxDelay;
    }

    function explodeParticles() {
        particles.forEach(p => {
             // Give them a random push outward from center
             const dx = p.x - width/2;
             const dy = p.y - height/2;
             const dist = Math.sqrt(dx*dx + dy*dy) + 0.1;
             
             // Initial outward explosion velocity
             p.vx = (dx / dist) * (Math.random() * 10 + 5);
             p.vy = (dy / dist) * (Math.random() * 10 + 5);
             p.active = false;
        });
    }

    function restartSequence() {
        stateStartTime = Date.now();
        animationState = 'chaos';
        calculateTextPoints();
    }

    // Mouse tracking
    const mouse = { x: null, y: null };
    window.addEventListener('mousemove', e => {
        mouse.x = e.clientX;
        mouse.y = e.clientY;
    });
    window.addEventListener('mouseleave', () => {
        mouse.x = null;
        mouse.y = null;
    });

    // Main Loop
    function animate() {
        ctx.clearRect(0, 0, width, height);
        
        const now = Date.now();
        const elapsed = now - stateStartTime;

        // State Machine
        switch (animationState) {
            case 'chaos':
                // Swirl for a bit
                if (elapsed > 1500) {
                    animationState = 'assembling';
                    stateStartTime = now;
                    assignParticlesToTargets();
                }
                break;
                
            case 'assembling':
                // Wait for all parts to assemble
                if (elapsed > currentAssemblyDuration) { 
                    animationState = 'holding';
                    stateStartTime = now;
                }
                break;

            case 'holding':
                if (elapsed > config.holdDuration) {
                    animationState = 'dispersing';
                    stateStartTime = now;
                    explodeParticles();
                }
                break;

            case 'dispersing':
                // Allow explosion to settle back into gentle chaos
                if (elapsed > 1000) {
                    animationState = 'chaos';
                    stateStartTime = now;
                    
                    // Cycle to next text in sequence
                    currentSequenceIndex = (currentSequenceIndex + 1) % config.textSequence.length;
                    
                    // Recalculate points for the chosen text
                    calculateTextPoints();
                }
                break;
        }

        particles.forEach(p => {
            p.update(mouse);
            p.draw(ctx);
        });

        animationFrameId = requestAnimationFrame(animate);
    }

    // Start
    init();

</script>
</body>
</html>
